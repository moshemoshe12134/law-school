<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Legal Citation Extractor</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600&display=swap");

    :root {
      color-scheme: dark;
      --bg-1: #0b0f14;
      --bg-2: #141a22;
      --bg-3: #1b222c;
      --ink: #e8eef5;
      --muted: #a9b4c2;
      --accent: #70d6b0;
      --accent-2: #f4c16d;
      --card: rgba(19, 24, 32, 0.78);
      --border: rgba(143, 162, 185, 0.28);
      --shadow: 0 24px 70px rgba(0, 0, 0, 0.35);
    }

    * { box-sizing: border-box; }
    body {
      font-family: "Space Grotesk", system-ui, -apple-system, Segoe UI, Arial, sans-serif;
      margin: 0;
      color: var(--ink);
      background:
        radial-gradient(1200px 600px at 10% 0%, rgba(112, 214, 176, 0.18), transparent 55%),
        radial-gradient(900px 500px at 90% 10%, rgba(244, 193, 109, 0.14), transparent 50%),
        linear-gradient(145deg, var(--bg-1), var(--bg-3));
      min-height: 100vh;
    }

    #asciiBg {
      position: fixed;
      inset: 0;
      margin: 0;
      pointer-events: none;
      z-index: 0;
      opacity: 0.25;
      color: #b6c2d1;
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      line-height: 1.1;
      display: grid;
      place-items: center;
    }

    .app { position: relative; z-index: 1; }
    header {
      padding: 20px 22px 12px;
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(8px);
      background: rgba(10, 12, 16, 0.5);
    }
    header h1 { margin: 0; font-size: 20px; letter-spacing: 0.6px; }
    header p { margin: 6px 0 0; font-size: 13px; opacity: 0.8; color: var(--muted); }

    .wrap {
      display: grid;
      grid-template-columns: 1.25fr 0.75fr;
      gap: 16px;
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto;
    }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }

    .card {
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      background: var(--card);
      box-shadow: var(--shadow);
      backdrop-filter: blur(12px);
    }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    textarea {
      width: 100%;
      min-height: 280px;
      resize: vertical;
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12.5px;
      line-height: 1.55;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(10, 12, 16, 0.6);
      color: var(--ink);
    }
    textarea:focus,
    input[type="text"]:focus {
      outline: 2px solid rgba(112, 214, 176, 0.35);
      border-color: rgba(112, 214, 176, 0.7);
    }
    textarea.error { border-color: rgba(205,68,68,.7); background: rgba(205,68,68,.08); }
    button {
      border: 1px solid var(--border);
      background: rgba(12, 14, 18, 0.45);
      padding: 8px 12px;
      border-radius: 12px;
      cursor: pointer;
      color: var(--ink);
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }
    button:hover {
      transform: translateY(-1px);
      border-color: rgba(112, 214, 176, 0.5);
      box-shadow: 0 8px 20px rgba(0,0,0,0.2);
    }
    button.primary {
      background: linear-gradient(120deg, rgba(112, 214, 176, 0.35), rgba(244, 193, 109, 0.25));
      font-weight: 600;
    }
    button:disabled { opacity: .5; cursor: not-allowed; transform: none; box-shadow: none; }

    .small { font-size: 12px; opacity: .85; color: var(--muted); }
    #linkStatus { color: var(--accent); }
    #linkStatus.error { color: #e46c6c; }
    .pill {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(12, 14, 18, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.4px;
    }
    .list { margin-top: 10px; display: grid; gap: 8px; }
    .item {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: start;
      cursor: pointer;
      background: rgba(12, 14, 18, 0.4);
      transition: border-color 0.15s ease, transform 0.15s ease;
    }
    .item:hover { border-color: rgba(112, 214, 176, 0.6); transform: translateY(-1px); }
    .cite { font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 12.5px; }
    .meta { display: flex; gap: 6px; align-items: center; justify-content: flex-end; flex-wrap: wrap; }
    .count { font-variant-numeric: tabular-nums; }
    .tag { font-size: 10.5px; opacity: .85; border: 1px solid var(--border); border-radius: 999px; padding: 3px 7px; background: rgba(12, 14, 18, 0.4); }
    .citeLink {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(112, 214, 176, 0.6);
      color: var(--ink);
      text-decoration: none;
      background: rgba(112, 214, 176, 0.18);
    }
    .citeLink:hover { border-color: rgba(244, 193, 109, 0.8); }

    .outText {
      white-space: pre-wrap;
      word-break: break-word;
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12.5px;
      line-height: 1.55;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      min-height: 120px;
      background: rgba(10, 12, 16, 0.6);
    }
    mark.hl {
      padding: 0 2px;
      border-radius: 4px;
      background: #ffe900;
      color: #0b0f14;
      box-shadow: 0 0 10px rgba(255, 233, 0, 0.4);
    }
    .footerRow { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; justify-content: space-between; margin-top: 10px; }
    .right { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; justify-content: flex-end; }
    input[type="text"] {
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      min-width: 220px;
      background: rgba(10, 12, 16, 0.6);
      color: var(--ink);
    }
    input[type="file"] { width: 100%; color: var(--muted); }

    .field { display: grid; gap: 6px; }
    .label { font-size: 12px; opacity: .9; letter-spacing: 0.3px; text-transform: uppercase; }
    .help { font-size: 11.5px; opacity: .8; color: var(--muted); }
    .help.error { color: #e46c6c; opacity: 1; }
    .tabs { display: inline-flex; border: 1px solid var(--border); border-radius: 999px; overflow: hidden; background: rgba(10, 12, 16, 0.6); }
    .tabs button { border: none; padding: 6px 12px; border-right: 1px solid var(--border); background: transparent; }
    .tabs button:last-child { border-right: none; }
    .tabs button.active { background: rgba(112, 214, 176, 0.2); font-weight: 600; }
    .sourcePanel { display: none; margin-top: 10px; }
    .sourcePanel.active { display: block; }
    .dropzone {
      border: 1px dashed rgba(143, 162, 185, 0.5);
      border-radius: 14px;
      padding: 14px;
      display: grid;
      gap: 8px;
      align-items: center;
      text-align: center;
      background: rgba(10, 12, 16, 0.5);
    }
    .dropzone.drag { background: rgba(112, 214, 176, 0.1); border-color: rgba(112, 214, 176, 0.7); }
    .fileMeta {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11.5px;
      background: rgba(10, 12, 16, 0.6);
    }
    .fileMeta button { padding: 3px 8px; }
    .preview {
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px;
      line-height: 1.5;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      min-height: 84px;
      max-height: 140px;
      overflow: auto;
      background: rgba(10, 12, 16, 0.6);
      color: var(--muted);
    }
    .snippet {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(10, 12, 16, 0.55);
      margin-bottom: 10px;
    }
    .snippet:last-child { margin-bottom: 0; }
    .snippetHeader {
      font-size: 11px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      color: var(--muted);
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <pre id="asciiBg" aria-hidden="true"></pre>
  <div class="app">
    <header>
      <h1>Legal Citation Extractor</h1>
      <p>Paste, upload, or fetch a URL. Parse citations and link to CourtListener. Click a citation to highlight all occurrences.</p>
    </header>

    <div class="wrap">
    <section class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row">
          <span class="pill">Input</span>
          <span class="small" id="stats"></span>
        </div>
        <div class="row">
          <button id="btnExample">Load example</button>
          <button id="btnClear">Clear</button>
          <button class="primary" id="btnParse">Parse citations</button>
        </div>
      </div>

      <div class="row" style="justify-content: space-between; margin-top: 8px;">
        <div class="row">
          <span class="label">Source</span>
          <div class="tabs" role="tablist" aria-label="Input source">
            <button id="tabPaste" class="active" aria-selected="true">Paste</button>
            <button id="tabUpload" aria-selected="false">Upload</button>
            <button id="tabUrl" aria-selected="false">URL</button>
          </div>
        </div>
        <span class="small" id="liveLabel">Live preview + linking</span>
      </div>

      <div class="sourcePanel active" id="panelPaste">
        <div class="field">
          <label class="label" for="input">Paste case text</label>
          <textarea id="input" placeholder="Example: Brown v. Board of Education, 347 U.S. 483 (1954)"></textarea>
          <div class="help" id="inputHelp">Expected formats: "347 U.S. 483 (1954)", "42 U.S.C. § 1983", "Fed. R. Civ. P. 12(b)(6)".</div>
          <div class="help error" id="inputError" style="display:none;">Add text to parse citations.</div>
        </div>
      </div>

      <div class="sourcePanel" id="panelUpload">
        <div class="field">
          <div class="label">Upload a document</div>
          <div class="dropzone" id="dropzone">
            <div class="small">Drag & drop a file here, or click to choose.</div>
            <input id="fileInput" type="file" accept=".txt,.md,.rtf,.doc,.docx,.pdf" />
          </div>
          <div class="row" id="fileRow" style="display:none;">
            <span class="fileMeta" id="fileMeta"></span>
          </div>
          <div class="help" id="fileHelp">Tip: plain text works best; PDF/DOCX may need a converter.</div>
          <div class="help error" id="fileError" style="display:none;"></div>
          <div class="preview" id="filePreview">(File preview will appear here.)</div>
        </div>
      </div>

      <div class="sourcePanel" id="panelUrl">
        <div class="field">
          <label class="label" for="urlInput">Add a URL</label>
          <div class="row">
            <input id="urlInput" type="text" placeholder="https://example.com/opinion" />
            <button id="btnFetch">Fetch</button>
          </div>
          <div class="help">We'll pull visible text and parse citations from the page.</div>
          <div class="help error" id="urlError" style="display:none;"></div>
          <div class="preview" id="urlPreview">(URL preview will appear here.)</div>
        </div>
      </div>

      <div class="footerRow">
        <div class="small">
          Tips: This is regex-based parsing, so it's heuristic (not a full Bluebook parser).
        </div>
        <div class="right">
          <button id="btnCopyJson" disabled>Copy JSON</button>
          <button id="btnCopyList" disabled>Copy list</button>
        </div>
      </div>
    </section>

    <aside class="card">
      <div class="row" style="justify-content: space-between;">
        <div class="row">
          <span class="pill">Citations</span>
          <span class="small" id="countLabel">0 found</span>
          <span class="small" id="linkStatus"></span>
        </div>
        <div class="row">
          <input id="filter" type="text" placeholder="Filter citations..." />
          <button id="btnResetHighlight" disabled>Reset highlight</button>
        </div>
      </div>

      <div class="list" id="results"></div>

      <hr style="margin: 12px 0; border: none; border-top: 1px solid rgba(128,128,128,.25);" />

      <div class="row">
        <span class="pill">Text with highlights</span>
        <span class="small" id="hlLabel"></span>
      </div>
      <div class="outText" id="outputText">(Run "Parse citations" to enable context view.)</div>
    </aside>
    </div>
  </div>

<script>
(() => {
  const elInput = document.getElementById("input");
  const elStats = document.getElementById("stats");
  const elResults = document.getElementById("results");
  const elCountLabel = document.getElementById("countLabel");
  const elFilter = document.getElementById("filter");
  const elOutputText = document.getElementById("outputText");
  const elHlLabel = document.getElementById("hlLabel");
  const elInputHelp = document.getElementById("inputHelp");
  const elInputError = document.getElementById("inputError");
  const elLiveLabel = document.getElementById("liveLabel");
  const elLinkStatus = document.getElementById("linkStatus");
  const asciiBg = document.getElementById("asciiBg");

  const tabPaste = document.getElementById("tabPaste");
  const tabUpload = document.getElementById("tabUpload");
  const tabUrl = document.getElementById("tabUrl");
  const panelPaste = document.getElementById("panelPaste");
  const panelUpload = document.getElementById("panelUpload");
  const panelUrl = document.getElementById("panelUrl");

  const dropzone = document.getElementById("dropzone");
  const fileInput = document.getElementById("fileInput");
  const fileMeta = document.getElementById("fileMeta");
  const fileRow = document.getElementById("fileRow");
  const fileError = document.getElementById("fileError");
  const fileHelp = document.getElementById("fileHelp");
  const filePreview = document.getElementById("filePreview");

  const urlInput = document.getElementById("urlInput");
  const btnFetch = document.getElementById("btnFetch");
  const urlError = document.getElementById("urlError");
  const urlPreview = document.getElementById("urlPreview");

  const btnParse = document.getElementById("btnParse");
  const btnClear = document.getElementById("btnClear");
  const btnExample = document.getElementById("btnExample");
  const btnCopyJson = document.getElementById("btnCopyJson");
  const btnCopyList = document.getElementById("btnCopyList");
  const btnResetHighlight = document.getElementById("btnResetHighlight");

  let lastParsed = []; // [{text, type, count}]
  let originalText = "";
  let activeSource = "paste";
  let liveTimer = null;
  let lookupTimer = null;
  let lookupInFlight = 0;
  let linkError = "";

  const COURT_LISTENER_BASE = "https://www.courtlistener.com/api/rest/v3/citation-lookup/";
  const lookupCache = new Map();
  const OUTPUT_PROMPT = "(Run \"Parse citations\" to enable context view.)";
  const OUTPUT_READY = "(Select a citation to view context.)";

  // ---------- Citation patterns (heuristics) ----------
  // We intentionally use multiple patterns and then merge/dedupe results.
  const patterns = [
    // Case citations: e.g., "410 U.S. 113 (1973)", "347 U.S. 483, 495 (1954)"
    { type: "case", re: /\b\d{1,4}\s+(?:U\.S\.|S\.Ct\.|L\.Ed\. ?2d|F\. ?\d+d|F\. ?Supp\. ?\d*|F\. ?App'?x|P\. ?\d+d|N\.E\. ?\d+d|N\.W\. ?\d+d|So\. ?\d+d|A\. ?\d+d)\s+\d{1,5}(?:\s*,\s*\d{1,5})*\s*\(\d{4}\)/g },

    // Case names w/ reporter: "Brown v. Board of Education, 347 U.S. 483 (1954)"
    // (This is broad; we capture the whole clause up to the year paren.)
    { type: "case_name", re: /\b[A-Z][A-Za-z0-9.&'\-]+(?:\s+[A-Z][A-Za-z0-9.&'\-]+)*\s+v\.?\s+[A-Z][A-Za-z0-9.&'\-]+(?:\s+[A-Z][A-Za-z0-9.&'\-]+)*,\s+\d{1,4}\s+(?:U\.S\.|S\.Ct\.|L\.Ed\. ?2d|F\. ?\d+d|F\. ?Supp\. ?\d*|F\. ?App'?x)\s+\d{1,5}(?:\s*,\s*\d{1,5})*\s*\(\d{4}\)/g },

    // U.S.C. citations: "42 U.S.C. § 1983" or "18 U.S.C. §§ 371, 1343"
    { type: "usc", re: /\b\d+\s+U\.S\.C\.?\s+§{1,2}\s*[\w\-–—.]+(?:\s*\([\w\d]+\))*?(?:\s*,\s*[\w\-–—.]+(?:\s*\([\w\d]+\))*)*/g },

    // C.F.R. citations: "29 C.F.R. § 541.200"
    { type: "cfr", re: /\b\d+\s+C\.F\.R\.?\s+§{1,2}\s*[\w\-–—.]+(?:\s*\([\w\d]+\))*/g },

    // State codes (generic): "N.Y. Penal Law § 125.25", "Cal. Civ. Code § 1714"
    { type: "state_code", re: /\b(?:N\.Y\.|Cal\.|Tex\.|Fla\.|Ill\.|Mass\.|N\.J\.|Pa\.|Wash\.|Va\.|Md\.)\s+(?:Penal|Crim\.|Civ\.|Gen\.|Fam\.|Bus\.|Lab\.)\s*(?:Law|Code|Proc\.|Reg\.)\s+§{1,2}\s*[\w\-–—.]+(?:\s*\([\w\d]+\))*/g },

    // Rules: "Fed. R. Civ. P. 12(b)(6)", "Fed. R. Evid. 403"
    { type: "rule", re: /\bFed\.\s+R\.\s+(?:Civ|Crim|Evid|App)\.\s+P\.?\s+\d+(?:\([a-z0-9]+\))*|\bFed\.\s+R\.\s+Evid\.\s+\d+/g },

    // Short forms: "Id.", "id.", "supra", "infra"
    { type: "short_form", re: /\b(?:Id\.|id\.|supra|infra)\b/g },
  ];

  // Escape HTML for safe rendering
  function esc(s) {
    return s.replace(/[&<>"]/g, c => ({ "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;" }[c]));
  }

  // Normalize citation text for dedupe (basic)
  function normalize(cite) {
    return cite
      .replace(/\s+/g, " ")
      .replace(/[\u201c\u201d]/g, '"')
      .replace(/[\u2019]/g, "'")
      .trim();
  }

  function countMatches(haystack, needle) {
    if (!needle) return 0;
    // Escape regex special chars
    const escaped = needle.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const re = new RegExp(escaped, "g");
    const m = haystack.match(re);
    return m ? m.length : 0;
  }

  function extractCitations(text) {
    const found = [];
    for (const p of patterns) {
      const matches = text.match(p.re);
      if (matches) {
        for (const m of matches) {
          found.push({ text: normalize(m), type: p.type });
        }
      }
    }

    // Dedupe by normalized text; merge types
    const map = new Map();
    for (const f of found) {
      const key = f.text;
      if (!map.has(key)) map.set(key, { text: f.text, types: new Set([f.type]) });
      else map.get(key).types.add(f.type);
    }

    const deduped = Array.from(map.values()).map(x => ({
      text: x.text,
      type: Array.from(x.types).join(", "),
      count: countMatches(text, x.text),
    }));

    // Sort by count desc, then alphabetical
    deduped.sort((a,b) => (b.count - a.count) || a.text.localeCompare(b.text));
    return deduped;
  }

  function setActiveSource(source) {
    activeSource = source;
    tabPaste.classList.toggle("active", source === "paste");
    tabUpload.classList.toggle("active", source === "upload");
    tabUrl.classList.toggle("active", source === "url");
    tabPaste.setAttribute("aria-selected", source === "paste");
    tabUpload.setAttribute("aria-selected", source === "upload");
    tabUrl.setAttribute("aria-selected", source === "url");
    panelPaste.classList.toggle("active", source === "paste");
    panelUpload.classList.toggle("active", source === "upload");
    panelUrl.classList.toggle("active", source === "url");
  }

  function renderList(items) {
    elResults.innerHTML = "";
    if (!items.length) {
      elResults.innerHTML = `<div class="small" style="opacity:.8">No citations found (or patterns didn't match).</div>`;
      return;
    }

    for (const item of items) {
      const div = document.createElement("div");
      div.className = "item";
      const linkHtml = item.url
        ? `<a class="citeLink" href="${esc(item.url)}" target="_blank" rel="noopener" title="${esc(item.title || "Open in CourtListener")}">Open</a>`
        : "";
      div.innerHTML = `
        <div class="cite">${esc(item.text)}</div>
        <div class="meta">
          ${linkHtml}
          <span class="tag" title="Detected category">${esc(item.type)}</span>
          <span class="count pill" title="Occurrences in text">${item.count}</span>
        </div>
      `;
      const link = div.querySelector(".citeLink");
      if (link) link.addEventListener("click", (e) => e.stopPropagation());
      div.addEventListener("click", () => highlightCitation(item.text));
      elResults.appendChild(div);
    }
  }

  function highlightAll(text, items) {
    if (!text) return "";
    if (!items.length) return esc(text);
    const needles = items
      .map(x => x.text)
      .sort((a, b) => b.length - a.length)
      .map(x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
    const re = new RegExp(needles.join("|"), "g");
    const parts = text.split(re);
    const matches = text.match(re) || [];
    let html = "";
    for (let i = 0; i < parts.length; i++) {
      html += esc(parts[i]);
      if (i < matches.length) html += `<mark class="hl">${esc(matches[i])}</mark>`;
    }
    return html;
  }

  function highlightCitation(citation) {
    if (!originalText) return;
    const escaped = citation.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const re = new RegExp(escaped, "g");

    // We must re-run highlight on the raw originalText, but render with escaping.
    // Approach: split originalText by matches and rebuild with <mark>.
    const parts = originalText.split(re);
    const matches = originalText.match(re) || [];

    let html = "";
    for (let i = 0; i < parts.length; i++) {
      html += esc(parts[i]);
      if (i < matches.length) html += `<mark class="hl">${esc(matches[i])}</mark>`;
    }

    elOutputText.innerHTML = html;
    elHlLabel.textContent = `Highlighting: ${citation} (${matches.length}×)`;
    btnResetHighlight.disabled = false;
  }

  function resetHighlight() {
    elOutputText.textContent = originalText || "(Run \"Parse citations\" to see highlights here.)";
    elHlLabel.textContent = "";
    btnResetHighlight.disabled = true;
  }

  function updateStats() {
    const t = elInput.value || "";
    const chars = t.length;
    const lines = t ? t.split(/\r\n|\r|\n/).length : 0;
    elStats.textContent = t ? `${chars.toLocaleString()} chars • ${lines} lines` : "";
  }

  function setInputError(message) {
    if (!message) {
      elInputError.style.display = "none";
      elInput.classList.remove("error");
      return;
    }
    elInputError.textContent = message;
    elInputError.style.display = "block";
    elInput.classList.add("error");
  }

  function applyFilter() {
    const q = (elFilter.value || "").toLowerCase().trim();
    const filtered = !q ? lastParsed : lastParsed.filter(x =>
      x.text.toLowerCase().includes(q) || x.type.toLowerCase().includes(q)
    );
    elCountLabel.textContent = `${filtered.length} found`;
    renderList(filtered);
  }

  function applyCachedLinks(items) {
    for (const item of items) {
      const hit = lookupCache.get(item.text);
      if (hit) {
        item.url = hit.url;
        item.title = hit.title || "";
      }
    }
  }

  function updateLinkStatus() {
    const linked = lastParsed.filter(x => x.url).length;
    elLinkStatus.classList.toggle("error", Boolean(linkError));
    if (linkError) {
      elLinkStatus.textContent = linkError;
      return;
    }
    if (lookupInFlight > 0) {
      elLinkStatus.textContent = "Linking...";
      return;
    }
    elLinkStatus.textContent = linked ? `${linked} linked` : "";
  }

  function extractLookupItems(data) {
    if (!data) return [];
    if (Array.isArray(data)) return data;
    if (Array.isArray(data.results)) return data.results;
    if (Array.isArray(data.citations)) return data.citations;
    if (Array.isArray(data.citation)) return data.citation;
    if (data.citations && typeof data.citations === "object") {
      return Object.entries(data.citations).map(([key, val]) => ({
        ...(val || {}),
        citation: (val && val.citation) || key,
      }));
    }
    const entries = Object.entries(data);
    if (entries.length && entries.every(([, v]) => v && typeof v === "object")) {
      return entries.map(([key, val]) => ({
        ...(val || {}),
        citation: (val && val.citation) || key,
      }));
    }
    return [];
  }

  function normalizeLookupItems(data) {
    const items = extractLookupItems(data);
    const results = [];
    for (const item of items) {
      const citeSource = item.citation || item.cite || item.citation_text || item.citation_string || item.reporter;
      const citeText = Array.isArray(citeSource) ? citeSource[0] : citeSource;
      if (!citeText) continue;
      let url = item.absolute_url || item.absolute || item.url;
      if (!url) continue;
      if (!/^https?:\/\//i.test(url)) url = `https://www.courtlistener.com${url}`;
      results.push({
        cite: normalize(String(citeText)),
        url,
        title: item.case_name || item.case_name_short || item.case_name_full || "",
      });
    }
    return results;
  }

  function scheduleLookup(items) {
    if (!items.length) return;
    const candidates = items.filter(item => item.type.includes("case"));
    const missing = [];
    const seen = new Set();
    for (const item of candidates) {
      if (lookupCache.has(item.text) || seen.has(item.text)) continue;
      seen.add(item.text);
      missing.push(item.text);
    }
    if (!missing.length) return;
    clearTimeout(lookupTimer);
    lookupTimer = setTimeout(() => lookupCourtListener(missing), 350);
  }

  async function lookupCourtListener(cites) {
    const maxBatch = 40;
    const batch = cites.slice(0, maxBatch);
    linkError = "";
    lookupInFlight += 1;
    updateLinkStatus();
    try {
      const params = new URLSearchParams();
      params.set("cites", batch.join("\n"));
      const res = await fetch(`${COURT_LISTENER_BASE}?${params.toString()}`, {
        headers: { "Accept": "application/json" },
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      const hits = normalizeLookupItems(data);
      for (const hit of hits) {
        lookupCache.set(hit.cite, { url: hit.url, title: hit.title });
      }
      applyCachedLinks(lastParsed);
      applyFilter();
    } catch (err) {
      linkError = "Linking failed";
      setTimeout(() => {
        linkError = "";
        updateLinkStatus();
      }, 2000);
    } finally {
      lookupInFlight -= 1;
      updateLinkStatus();
    }
  }

  async function copyText(s) {
    await navigator.clipboard.writeText(s);
  }

  function parseAndRender({ live = false } = {}) {
    const text = elInput.value || "";
    originalText = text;

    if (!text.trim()) {
      setInputError("Add text to parse citations.");
      elResults.innerHTML = "";
      elCountLabel.textContent = "0 found";
      elLinkStatus.textContent = "";
      linkError = "";
      elOutputText.textContent = "(No input text.)";
      elHlLabel.textContent = "";
      btnCopyJson.disabled = true;
      btnCopyList.disabled = true;
      btnResetHighlight.disabled = true;
      return;
    }

    setInputError("");
    lastParsed = extractCitations(text);
    applyCachedLinks(lastParsed);
    elCountLabel.textContent = `${lastParsed.length} found`;
    renderList(lastParsed);
    updateLinkStatus();

    if (live) {
      elOutputText.innerHTML = highlightAll(text, lastParsed);
      elHlLabel.textContent = lastParsed.length ? `Showing all citations (${lastParsed.length})` : "No citations found yet.";
    } else {
      elOutputText.textContent = text;
      elHlLabel.textContent = "";
    }

    btnCopyJson.disabled = lastParsed.length === 0;
    btnCopyList.disabled = lastParsed.length === 0;
    btnResetHighlight.disabled = true;
    scheduleLookup(lastParsed);
  }

  function scheduleLiveParse() {
    clearTimeout(liveTimer);
    liveTimer = setTimeout(() => parseAndRender({ live: true }), 250);
  }

  // ---------- Event handlers ----------
  btnParse.addEventListener("click", () => {
    parseAndRender({ live: true });
  });

  btnClear.addEventListener("click", () => {
    elInput.value = "";
    originalText = "";
    lastParsed = [];
    linkError = "";
    elResults.innerHTML = "";
    elCountLabel.textContent = "0 found";
    elLinkStatus.textContent = "";
    elOutputText.textContent = "(Run \"Parse citations\" to see highlights here.)";
    elHlLabel.textContent = "";
    elFilter.value = "";
    btnCopyJson.disabled = true;
    btnCopyList.disabled = true;
    btnResetHighlight.disabled = true;
    fileInput.value = "";
    fileRow.style.display = "none";
    fileMeta.textContent = "";
    filePreview.textContent = "(File preview will appear here.)";
    fileError.style.display = "none";
    urlInput.value = "";
    urlPreview.textContent = "(URL preview will appear here.)";
    urlError.style.display = "none";
    updateStats();
  });

  btnExample.addEventListener("click", () => {
    elInput.value =
`Brown v. Board of Education, 347 U.S. 483 (1954), held that segregated public schools violate the Equal Protection Clause.
See also Roe v. Wade, 410 U.S. 113, 164 (1973). Compare 42 U.S.C. § 1983 with 18 U.S.C. §§ 371, 1343.
Under Fed. R. Civ. P. 12(b)(6), a complaint must state a claim. Id. supra. 29 C.F.R. § 541.200.`;
    updateStats();
    scheduleLiveParse();
  });

  elFilter.addEventListener("input", applyFilter);

  btnCopyJson.addEventListener("click", async () => {
    const payload = JSON.stringify(lastParsed, null, 2);
    await copyText(payload);
    btnCopyJson.textContent = "Copied JSON ✓";
    setTimeout(() => (btnCopyJson.textContent = "Copy JSON"), 1200);
  });

  btnCopyList.addEventListener("click", async () => {
    const payload = lastParsed.map(x => `${x.text}  [${x.type}]  (${x.count}×)`).join("\n");
    await copyText(payload);
    btnCopyList.textContent = "Copied list ✓";
    setTimeout(() => (btnCopyList.textContent = "Copy list"), 1200);
  });

  btnResetHighlight.addEventListener("click", resetHighlight);

  elInput.addEventListener("input", () => {
    updateStats();
    scheduleLiveParse();
  });
  updateStats();

  tabPaste.addEventListener("click", () => setActiveSource("paste"));
  tabUpload.addEventListener("click", () => setActiveSource("upload"));
  tabUrl.addEventListener("click", () => setActiveSource("url"));

  dropzone.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropzone.classList.add("drag");
  });
  dropzone.addEventListener("dragleave", () => dropzone.classList.remove("drag"));
  dropzone.addEventListener("drop", (e) => {
    e.preventDefault();
    dropzone.classList.remove("drag");
    const files = e.dataTransfer.files;
    if (files && files[0]) {
      fileInput.files = files;
      fileInput.dispatchEvent(new Event("change"));
    }
  });

  fileInput.addEventListener("change", async () => {
    const file = fileInput.files && fileInput.files[0];
    if (!file) return;
    fileError.style.display = "none";
    fileHelp.style.opacity = "1";
    fileRow.style.display = "flex";
    fileMeta.innerHTML = `${file.name} • ${(file.size / 1024).toFixed(1)} KB <button id="btnRemoveFile" type="button">Remove</button>`;
    const btnRemoveFile = document.getElementById("btnRemoveFile");
    btnRemoveFile.addEventListener("click", () => {
      fileInput.value = "";
      fileRow.style.display = "none";
      filePreview.textContent = "(File preview will appear here.)";
      elInput.value = "";
      updateStats();
      scheduleLiveParse();
    });

    const isText = file.type.startsWith("text/") || /\.txt|\.md|\.rtf$/i.test(file.name);
    if (!isText) {
      fileError.textContent = "This file type isn't readable in the browser yet. Try .txt or paste the text.";
      fileError.style.display = "block";
      fileHelp.style.opacity = ".6";
      return;
    }

    const text = await file.text();
    elInput.value = text;
    filePreview.textContent = text.slice(0, 600) || "(No text detected.)";
    updateStats();
    scheduleLiveParse();
  });

  btnFetch.addEventListener("click", async () => {
    const url = (urlInput.value || "").trim();
    urlError.style.display = "none";
    if (!url) {
      urlError.textContent = "Enter a URL to fetch.";
      urlError.style.display = "block";
      return;
    }

    try {
      btnFetch.disabled = true;
      btnFetch.textContent = "Fetching...";
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const text = await res.text();
      const snippet = text.replace(/\s+/g, " ").slice(0, 600);
      urlPreview.textContent = snippet || "(No text detected.)";
      elInput.value = text;
      updateStats();
      scheduleLiveParse();
    } catch (err) {
      urlError.textContent = "Couldn't fetch this URL (blocked by CORS or network). Try paste or upload.";
      urlError.style.display = "block";
    } finally {
      btnFetch.disabled = false;
      btnFetch.textContent = "Fetch";
    }
  });

  if (asciiBg) {
    const shades = " .:-=+*#%@";
    const cubePoints = [
      [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
      [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1],
    ];
    const edges = [
      [0, 1], [1, 2], [2, 3], [3, 0],
      [4, 5], [5, 6], [6, 7], [7, 4],
      [0, 4], [1, 5], [2, 6], [3, 7],
    ];
    const state = { w: 80, h: 28, mx: 0, my: 0, t: 0 };

    function updateAsciiSize() {
      const charW = 9;
      const charH = 14;
      state.w = Math.max(50, Math.min(110, Math.floor(window.innerWidth / charW)));
      state.h = Math.max(20, Math.min(44, Math.floor(window.innerHeight / charH)));
    }

    function rotatePoint(p, ax, ay, az) {
      let [x, y, z] = p;
      let c = Math.cos(ax);
      let s = Math.sin(ax);
      let y1 = y * c - z * s;
      let z1 = y * s + z * c;
      y = y1; z = z1;

      c = Math.cos(ay);
      s = Math.sin(ay);
      let x1 = x * c + z * s;
      let z2 = -x * s + z * c;
      x = x1; z = z2;

      c = Math.cos(az);
      s = Math.sin(az);
      let x2 = x * c - y * s;
      let y2 = x * s + y * c;
      return [x2, y2, z];
    }

    function plotPoint(x, y, z, grid) {
      if (x < 0 || y < 0 || y >= state.h || x >= state.w) return;
      const t = Math.max(0, Math.min(1, (z + 1.6) / 3.2));
      const shade = shades[Math.floor(t * (shades.length - 1))];
      grid[y][x] = shade;
    }

    function drawLine(a, b, grid) {
      const steps = 14;
      for (let i = 0; i <= steps; i += 1) {
        const t = i / steps;
        const x = a[0] + (b[0] - a[0]) * t;
        const y = a[1] + (b[1] - a[1]) * t;
        const z = a[2] + (b[2] - a[2]) * t;
        const centerX = state.w / 2;
        const centerY = state.h / 2;
        const scale = Math.min(state.w, state.h) * 0.36;
        const persp = 2.8 / (z + 3.6);
        const px = Math.round(centerX + x * scale * persp);
        const py = Math.round(centerY + y * scale * persp);
        plotPoint(px, py, z, grid);
      }
    }

    function renderAscii() {
      state.t += 0.02;
      const ax = state.t * 0.7 + state.my * 0.9;
      const ay = state.t * 0.5 + state.mx * 1.1;
      const az = state.t * 0.35;
      const grid = Array.from({ length: state.h }, () => Array(state.w).fill(" "));
      const rotated = cubePoints.map(p => rotatePoint(p, ax, ay, az));
      for (const [a, b] of edges) {
        drawLine(rotated[a], rotated[b], grid);
      }
      asciiBg.textContent = grid.map(row => row.join("")).join("\n");
      requestAnimationFrame(renderAscii);
    }

    updateAsciiSize();
    window.addEventListener("resize", updateAsciiSize);
    window.addEventListener("mousemove", (e) => {
      state.mx = (e.clientX / window.innerWidth - 0.5) * 1.4;
      state.my = (e.clientY / window.innerHeight - 0.5) * 1.2;
    });
    renderAscii();
  }
})();
</script>
</body>
</html>
